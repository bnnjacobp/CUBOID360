<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Educational Bread Box Applet</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #fcfcfc;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
        }

        canvas {
            display: block;
        }

        #main-header {
            position: absolute;
            top: 15px;
            width: 100%;
            text-align: center;
            padding: 0 20px;
            box-sizing: border-box;
            font-size: clamp(16px, 2.2vw, 22px);
            font-weight: bold;
            color: #3e2723;
            z-index: 10;
            pointer-events: none;
        }

        /* --- UI Box Layout --- */
        #pointers-container {
            position: absolute;
            top: 70px;
            left: 20px;
            width: 450px;
            background: rgba(255, 255, 255, 0.95);
            border-left: 5px solid #8d6e63;
            border-radius: 4px;
            z-index: 20;
            box-shadow: 2px 2px 15px rgba(0, 0, 0, 0.08);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #box-header {
            padding: 12px 20px;
            background: #f1edea;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
            font-weight: bold;
            color: #3e2723;
            border-bottom: 1px solid #ddd;
        }

        #box-header:after {
            content: '▲';
            font-size: 10px;
            transition: transform 0.3s;
        }

        #pointers-container.minimized #box-header:after {
            transform: rotate(180deg);
        }

        /* Collapsible Section */
        #collapsible-content {
            max-height: 500px; /* Max height when open */
            transition: max-height 0.4s ease-out, opacity 0.3s;
            overflow-y: auto;
            padding: 0 20px;
        }

        #pointers-container.minimized #collapsible-content {
            max-height: 0;
            opacity: 0;
            padding: 0 20px;
        }

        /* Instruction - ALWAYS VISIBLE */
        #fixed-footer {
            padding: 15px 20px;
            border-top: 1px solid #eee;
            background: rgba(255, 255, 255, 0.95);
        }

        .instruction-text {
            color: #757575;
            font-style: italic;
            font-size: 13px;
            line-height: 1.4;
        }

        .pointer-item {
            margin: 20px 0;
            font-size: 13.5px;
            line-height: 1.5;
            color: #4e342e;
        }

        .pointer-item h3 {
            margin: 0 0 5px 0;
            font-size: 14px;
            color: #8d6e63;
        }

        #qr-display {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 150px;
            height: auto;
            background: white;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            z-index: 1000;
        }
    </style>
</head>

<body>

    <div id="main-header">
        A model of a cuboidal bread box is given. Your school has decided to donate many such boxes to charity. <br>
        Find the volume of the bread box by counting the unit cubes of breads filled in it!
    </div>

    <div id="pointers-container">
        <!-- HEADER (Always Visible & Clickable) -->
        <div id="box-header" onclick="document.getElementById('pointers-container').classList.toggle('minimized')">
            <span>Exploration Tasks</span>
            <small style="font-weight: normal; color: #888;">(Tap to minimize questions)</small>
        </div>
        
        <!-- QUESTIONS (Minimize-able) -->
        <div id="collapsible-content">
            <div class="pointer-item">
                <h3>1. The Sides of One Flat Layer of a Cuboid</h3>
                Breads are sliced in the shape of cubes. When you look at one flat layer of cuboid (like cubes of the bottom of the box), what does the number of cubes along one side tell you? How is it like the length of that layer? What about the number of cubes along the other side—how is it like the breadth (or width)?
            </div>

            <div class="pointer-item">
                <h3>2. All the Cubes in One Flat Layer of a Cuboid</h3>
                How many cubes are there in that single flat layer? Did you find that number by multiplying the length and the breadth? This number is called the area of the base. If the layer was 1 cube thick, this number would also be its volume.
            </div>

            <div class="pointer-item">
                <h3>3. Stacking the Layers Up</h3>
                How many of these flat layers are stacked on top of each other to make the whole box? How is this number the same as the height of the box?
            </div>

            <div class="pointer-item">
                <h3>4. All the Cubes in the Whole Box</h3>
                What is the total number of cubes in the entire box? This total number is called the volume of the box. How did you find it?
            </div>

            <div class="pointer-item">
                <h3>5. A Division Puzzle (Part 1)</h3>
                If you take the total volume of the box and divide it by the number of cubes in its bottom layer, what answer do you get? What is another name for that answer?
            </div>

            <div class="pointer-item" style="margin-bottom: 20px;">
                <h3>6. A Division Puzzle (Part 2)</h3>
                If you take the total volume of the box and divide it by its height, what answer do you get? Is this the number of cubes in just one layer? What else can you call this number?
            </div>
        </div>

        <!-- INSTRUCTION (Always Visible) -->
        <div id="fixed-footer">
            <div class="instruction-text">
                Use hand gestures to rotate and span the cuboid while exploring these concepts
            </div>
        </div>
    </div>

    <!-- THE QR CODE -->
    <img id="qr-display" src="breadboxqr.png" alt="Scan to explore">

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let breadGroup, exteriorEdges, acrylicMesh;
        let handles = [];
        const size = { x: 10, y: 1, z: 4 };

        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        let isDraggingHandle = false;
        let activeHandle = null;

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xfcfcfc);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(16, 12, 18);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            const light = new THREE.DirectionalLight(0xfff5e6, 1.5);
            light.position.set(10, 20, 15);
            scene.add(light);
            scene.add(new THREE.AmbientLight(0xffffff, 0.8));

            breadGroup = new THREE.Group();
            scene.add(breadGroup);

            acrylicMesh = new THREE.Mesh(
                new THREE.BoxGeometry(1, 1, 1),
                new THREE.MeshPhongMaterial({ color: 0xeeeeee, transparent: true, opacity: 0.1, shininess: 100 })
            );
            scene.add(acrylicMesh);

            exteriorEdges = new THREE.Group();
            scene.add(exteriorEdges);

            createHandles();
            updateCuboid();

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.mouseButtons = { LEFT: THREE.MOUSE.ROTATE, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.ROTATE };
            controls.touches = { ONE: THREE.TOUCH.ROTATE, TWO: THREE.TOUCH.DOLLY_PAN };

            window.addEventListener('pointerdown', onPointerDown);
            window.addEventListener('pointermove', onPointerMove);
            window.addEventListener('pointerup', onPointerUp);
            window.addEventListener('resize', onWindowResize);
        }

        function createHandles() {
            const handleGeo = new THREE.SphereGeometry(0.5);
            const handleMat = new THREE.MeshBasicMaterial({ visible: false });
            const corners = [[1,1,1],[1,1,-1],[1,-1,1],[1,-1,-1],[-1,1,1],[-1,1,-1],[-1,-1,1],[-1,-1,-1]];
            corners.forEach(dir => {
                const handle = new THREE.Mesh(handleGeo, handleMat);
                handle.userData = { dir: new THREE.Vector3(...dir) };
                scene.add(handle);
                handles.push(handle);
            });
        }

        function updateCuboid() {
            while (breadGroup.children.length > 0) breadGroup.remove(breadGroup.children[0]);
            while (exteriorEdges.children.length > 0) exteriorEdges.remove(exteriorEdges.children[0]);

            const crustMat = new THREE.MeshPhongMaterial({ color: 0xcd853f });
            const crumbMat = new THREE.MeshPhongMaterial({ color: 0xf5f5dc });
            const materials = [crumbMat, crumbMat, crustMat, crustMat, crumbMat, crumbMat];

            const startX = -(size.x / 2) + 0.5;
            const startY = -(size.y / 2) + 0.5;
            const startZ = -(size.z / 2) + 0.5;

            for (let i = 0; i < size.x; i++) {
                for (let j = 0; j < size.y; j++) {
                    for (let k = 0; k < size.z; k++) {
                        const cube = new THREE.Mesh(new THREE.BoxGeometry(0.95, 0.95, 0.95), materials);
                        cube.position.set(startX + i, startY + j, startZ + k);
                        breadGroup.add(cube);
                    }
                }
            }

            acrylicMesh.scale.set(size.x, size.y, size.z);
            exteriorEdges.add(new THREE.LineSegments(
                new THREE.EdgesGeometry(new THREE.BoxGeometry(size.x, size.y, size.z)),
                new THREE.LineBasicMaterial({ color: 0x333333 })
            ));

            const hX = size.x / 2, hY = size.y / 2, hZ = size.z / 2;
            handles.forEach(h => h.position.set(hX * h.userData.dir.x, hY * h.userData.dir.y, hZ * h.userData.dir.z));
        }

        function onPointerDown(e) {
            if (e.target.closest('#pointers-container') || e.target.id === 'qr-display') return;

            pointer.x = (e.clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(pointer, camera);
            const hits = raycaster.intersectObjects(handles);
            if (hits.length > 0) { isDraggingHandle = true; activeHandle = hits[0].object; controls.enabled = false; }
            else { isDraggingHandle = false; controls.enabled = true; }
        }

        function onPointerMove(e) {
            if (!isDraggingHandle || !activeHandle) return;
            pointer.x = (e.clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(pointer, camera);
            const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(camera.getWorldDirection(new THREE.Vector3()), activeHandle.position);
            const pt = new THREE.Vector3();
            if (raycaster.ray.intersectPlane(plane, pt)) {
                const ny = Math.max(1, Math.min(4, Math.round(Math.abs(pt.y) * 2)));
                if (ny !== size.y) { size.y = ny; updateCuboid(); }
            }
        }

        function onPointerUp() { isDraggingHandle = false; activeHandle = null; controls.enabled = true; }
        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
    </script>
</body>

</html>
