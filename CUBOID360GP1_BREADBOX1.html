<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Educational Bread Box Applet</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #fcfcfc;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
        }

        canvas {
            display: block;
        }

        #main-header {
            position: absolute;
            top: 15px;
            width: 100%;
            text-align: center;
            padding: 0 20px;
            box-sizing: border-box;
            font-size: clamp(16px, 2.2vw, 22px);
            font-weight: bold;
            color: #3e2723;
            z-index: 10;
            pointer-events: none;
        }

        /* --- UI Box Layout --- */
        #pointers-container {
            position: absolute;
            top: 70px;
            left: 20px;
            width: 450px;
            background: rgba(255, 255, 255, 0.95);
            border-left: 5px solid #8d6e63;
            border-radius: 4px;
            z-index: 20;
            box-shadow: 2px 2px 15px rgba(0, 0, 0, 0.08);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #box-header {
            padding: 12px 20px;
            background: #f1edea;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
            font-weight: bold;
            color: #3e2723;
            border-bottom: 1px solid #ddd;
        }

        #box-header:after {
            content: '▲';
            font-size: 10px;
            transition: transform 0.3s;
        }

        #pointers-container.minimized #box-header:after {
            transform: rotate(180deg);
        }

        /* Collapsible Section */
        #collapsible-content {
            max-height: 550px; 
            transition: max-height 0.4s ease-out, opacity 0.3s;
            overflow-y: auto;
            padding: 0 20px;
        }

        #pointers-container.minimized #collapsible-content {
            max-height: 0;
            opacity: 0;
            padding: 0 20px;
        }

        /* Instruction - ALWAYS VISIBLE */
        #fixed-footer {
            padding: 15px 20px;
            border-top: 1px solid #eee;
            background: rgba(255, 255, 255, 0.95);
        }

        .instruction-text {
            color: #757575;
            font-style: italic;
            font-size: 13px;
            line-height: 1.4;
        }

        .pointer-item {
            margin: 20px 0;
            font-size: 13.5px;
            line-height: 1.5;
            color: #4e342e;
        }

        .pointer-item h3 {
            margin: 0 0 5px 0;
            font-size: 14px;
            color: #8d6e63;
        }

        #qr-display {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 150px;
            height: auto;
            background: white;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            z-index: 1000;
        }
    </style>
</head>

<body>

    <div id="main-header">
        A model of a cuboidal bread box is given. Your school has decided to donate many such boxes to charity. <br>
        Find the volume of the bread box by counting the unit cubes of breads filled in it!
    </div>

    <div id="pointers-container">
        <!-- HEADER (Always Visible & Clickable) -->
        <div id="box-header" onclick="document.getElementById('pointers-container').classList.toggle('minimized')">
            <span>Concept Exploration</span>
            <small style="font-weight: normal; color: #888;">(Tap to Toggle)</small>
        </div>
        
        <!-- QUESTIONS (Simplified) -->
        <div id="collapsible-content">
            <div class="pointer-item">
                <h3>1. Length and Breadth</h3>
                Count the cubes along the edges of the bottom layer. How do these numbers match the <b>Length</b> and <b>Breadth</b> of the box?
            </div>

            <div class="pointer-item">
                <h3>2. The Base Area</h3>
                How many unit cubes are in one flat layer? If you multiply Length × Breadth, do you get this same total? This is called the <b>Base Area</b>.
            </div>

            <div class="pointer-item">
                <h3>3. Stacking for Height</h3>
                How many layers are stacked on top of each other? Relate this count to the <b>Height</b> of the entire box.
            </div>

            <div class="pointer-item">
                <h3>4. Finding the Volume</h3>
                What is the total number of unit cubes in the entire box? This total is the <b>Volume</b>. Can you calculate it by multiplying: Base Area × Height?
            </div>

            <div class="pointer-item">
                <h3>5. Working Backward (Part 1)</h3>
                If you take the Total Volume and divide it by the number of cubes in the bottom layer (Base Area), do you obtain the <b>Height</b>?
            </div>

            <div class="pointer-item" style="margin-bottom: 20px;">
                <h3>6. Working Backward (Part 2)</h3>
                If you divide the Total Volume by the box's Height, do you obtain the number of cubes in just one layer (the <b>Base Area</b>)?
            </div>
        </div>

        <!-- INSTRUCTION (Always Visible) -->
        <div id="fixed-footer">
            <div class="instruction-text">
                Use hand gestures to rotate and span the cuboid while exploring these concepts
            </div>
        </div>
    </div>

    <!-- THE QR CODE -->
    <img id="qr-display" src="breadboxqr.png" alt="Scan to explore">

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let breadGroup, exteriorEdges, acrylicMesh;
        let handles = [];
        const size = { x: 10, y: 1, z: 4 };

        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        let isDraggingHandle = false;
        let activeHandle = null;

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xfcfcfc);
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(16, 12, 18);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            const light = new THREE.DirectionalLight(0xfff5e6, 1.5);
            light.position.set(10, 20, 15);
            scene.add(light);
            scene.add(new THREE.AmbientLight(0xffffff, 0.8));

            breadGroup = new THREE.Group(); scene.add(breadGroup);
            acrylicMesh = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshPhongMaterial({ color: 0xeeeeee, transparent: true, opacity: 0.1, shininess: 100 }));
            scene.add(acrylicMesh);
            exteriorEdges = new THREE.Group(); scene.add(exteriorEdges);

            createHandles();
            updateCuboid();

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.mouseButtons = { LEFT: THREE.MOUSE.ROTATE, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.ROTATE };
            controls.touches = { ONE: THREE.TOUCH.ROTATE, TWO: THREE.TOUCH.DOLLY_PAN };

            window.addEventListener('pointerdown', (e) => {
                if (e.target.closest('#pointers-container') || e.target.id === 'qr-display') return;
                pointer.x = (e.clientX / window.innerWidth) * 2 - 1;
                pointer.y = -(e.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(pointer, camera);
                const hits = raycaster.intersectObjects(handles);
                if (hits.length > 0) { isDraggingHandle = true; activeHandle = hits[0].object; controls.enabled = false; }
                else { isDraggingHandle = false; controls.enabled = true; }
            });

            window.addEventListener('pointermove', (e) => {
                if (!isDraggingHandle || !activeHandle) return;
                pointer.x = (e.clientX / window.innerWidth) * 2 - 1;
                pointer.y = -(e.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(pointer, camera);
                const pt = new THREE.Vector3();
                raycaster.ray.intersectPlane(new THREE.Plane().setFromNormalAndCoplanarPoint(camera.getWorldDirection(new THREE.Vector3()), activeHandle.position), pt);
                const ny = Math.max(1, Math.min(4, Math.round(Math.abs(pt.y) * 2)));
                if (ny !== size.y) { size.y = ny; updateCuboid(); }
            });

            window.addEventListener('pointerup', () => { isDraggingHandle = false; activeHandle = null; controls.enabled = true; });
            window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
        }

        function createHandles() {
            const hGeo = new THREE.SphereGeometry(0.5);
            const hMat = new THREE.MeshBasicMaterial({ visible: false });
            const corners = [[1,1,1],[1,1,-1],[1,-1,1],[1,-1,-1],[-1,1,1],[-1,1,-1],[-1,-1,1],[-1,-1,-1]];
            corners.forEach(dir => {
                const handle = new THREE.Mesh(hGeo, hMat); handle.userData = { dir: new THREE.Vector3(...dir) };
                scene.add(handle); handles.push(handle);
            });
        }

        function updateCuboid() {
            while (breadGroup.children.length > 0) breadGroup.remove(breadGroup.children[0]);
            while (exteriorEdges.children.length > 0) exteriorEdges.remove(exteriorEdges.children[0]);
            const mats = [new THREE.MeshPhongMaterial({ color: 0xf5f5dc }), new THREE.MeshPhongMaterial({ color: 0xf5f5dc }), new THREE.MeshPhongMaterial({ color: 0xcd853f }), new THREE.MeshPhongMaterial({ color: 0xcd853f }), new THREE.MeshPhongMaterial({ color: 0xf5f5dc }), new THREE.MeshPhongMaterial({ color: 0xf5f5dc })];
            const startX = -(size.x/2)+0.5, startY = -(size.y/2)+0.5, startZ = -(size.z/2)+0.5;
            for (let i = 0; i < size.x; i++) {
                for (let j = 0; j < size.y; j++) {
                    for (let k = 0; k < size.z; k++) {
                        const cube = new THREE.Mesh(new THREE.BoxGeometry(0.95, 0.95, 0.95), mats);
                        cube.position.set(startX+i, startY+j, startZ+k); breadGroup.add(cube);
                    }
                }
            }
            acrylicMesh.scale.set(size.x, size.y, size.z);
            exteriorEdges.add(new THREE.LineSegments(new THREE.EdgesGeometry(new THREE.BoxGeometry(size.x,size.y,size.z)), new THREE.LineBasicMaterial({ color: 0x333333 })));
            const hX = size.x/2, hY = size.y/2, hZ = size.z/2;
            handles.forEach(h => h.position.set(hX*h.userData.dir.x, hY*h.userData.dir.y, hZ*h.userData.dir.z));
        }

        function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
    </script>
</body>

</html>
