<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>UAE Culture: Box of Dates - Volume Explorer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #ffffff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
        }

        canvas {
            display: block;
        }

        /* --- Main Page Heading --- */
        #main-header {
            position: absolute;
            top: 15px;
            width: 100%;
            text-align: center;
            font-size: clamp(20px, 3.5vw, 28px);
            font-weight: 800;
            color: #3B2314;
            /* Deep Chocolate Brown */
            z-index: 10;
            pointer-events: none;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.05);
        }

        /* --- Minimizing Side Panel Textbox --- */
        #info-box {
            position: absolute;
            top: 60px;
            left: 20px;
            width: 500px;
            background: rgba(255, 255, 255, 0.95);
            border-left: 8px solid #D2691E;
            border-radius: 15px;
            box-shadow: 2px 2px 20px rgba(0, 0, 0, 0.1);
            z-index: 20;
            overflow: hidden;
            transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            max-height: 800px;
        }

        #info-box.minimized {
            max-height: 42px;
            /* Only header height */
        }

        #info-box-header {
            padding: 12px 20px;
            background: rgba(210, 105, 30, 0.05);
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        }

        #info-box-header:after {
            content: '▼';
            font-size: 12px;
            color: #D2691E;
            transition: transform 0.3s;
        }

        #info-box.minimized #info-box-header:after {
            transform: rotate(-90deg);
        }

        .header-title {
            font-size: 14px;
            font-weight: bold;
            color: #D2691E;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #info-content {
            padding: 20px 25px;
        }

        #description {
            font-size: 15px;
            line-height: 1.5;
            color: #3e2723;
            margin-bottom: 15px;
        }

        .think-title {
            font-size: 17px;
            font-weight: bold;
            color: #D2691E;
            display: block;
            margin-bottom: 10px;
            text-decoration: underline;
        }

        .question {
            font-size: 14px;
            color: #4e342e;
            margin-bottom: 8px;
            font-weight: 600;
            display: list-item;
            list-style-type: square;
            margin-left: 20px;
        }

        .instruction-group {
            margin-top: 20px;
            padding-top: 12px;
            border-top: 1px solid #eee;
        }

        .instruction-text {
            display: block;
            font-size: 13px;
            color: #757575;
            /* Grey */
            font-style: italic;
            /* Italics */
            margin-bottom: 6px;
            line-height: 1.4;
        }

        /* --- Bottom UI Bar --- */
        #ui-bar-bottom {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 15px;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px 20px;
            border-radius: 50px;
            box-shadow: 0 4px 15px rgba(0, 136, 255, 0.2);
            z-index: 100;
            border: 1px solid #ddd;
        }

        .input-group {
            display: flex;
            align-items: center;
            gap: 5px;
            font-weight: bold;
            color: #3B2314;
            font-size: 14px;
        }

        .dimension-input {
            width: 40px;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 5px;
            text-align: center;
            font-size: 14px;
            outline: none;
        }

        .dimension-input:focus {
            border-color: #0088ff;
        }

        #toggle-btn {
            padding: 10px 20px;
            font-size: 14px;
            font-weight: bold;
            color: white;
            background-color: #0088ff;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            user-select: none;
            white-space: nowrap;
        }

        #toggle-btn.disabled {
            background-color: #555555;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        #toggle-btn:active {
            transform: scale(0.95);
        }

        /* --- QR Code Bottom Right --- */
        #qr-display {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 120px;
            height: 120px;
            background: white;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            z-index: 100;
        }
    </style>
</head>

<body>

    <div id="main-header">Exploring Volume Through a Box of Eid Gifts</div>

    <div id="info-box">
        <div id="info-box-header" onclick="document.getElementById('info-box').classList.toggle('minimized')">
            <span class="header-title">Instructions & Tasks</span>
        </div>
        <div id="info-content">
            <div id="description">
                This is a model of a box of balls having dates and nuts, commonly shared in the UAE during Islamic
                occasions such as Ramadan, Eid, and family gatherings, in the shape of a cuboid.
            </div>

            <span class="think-title">Think and Answer</span>
            <div class="question">What does the number of balls in each layer represent? Calculate the area of the
                base layer of the cuboid. Are these two values same or different?</div>
            <div class="question">What does the number of layers represent? Calculate the height of the cuboid. Are
                these two values same or different?</div>
            <div class="question">What does the total number of balls in all the layers together represent? Calculate
                the
                volume of the cuboid. Are these two values same or different?</div>
            <div class="question">What do you obtain if you divide the total number of balls by the number of layers?
                What
                do you obtain if you divide the volume of the cuboid by the height of the cuboid? Are the values same or
                different? If the values are same what does the value represent?.</div>
            <div class="question">What do you obtain if you divide the total number of balls by the number of balls in
                one
                layer? What do you obtain if you divide the volume of the cuboid by the surface area of the base of the
                cuboid? Are the values same or different? If the values are same what does the value represent?.</div>

            <div class="instruction-group">
                <span class="instruction-text">The interactive cuboid on the right can be expanded up to a dimension of 6×6×6. Use the input boxes to enter the length, breadth, and height of the required
                    cuboid. Disable the “Span” button to prevent accidental changes to the dimensions
                    of the cuboid.</span>
            </div>
        </div>
    </div>

    <!-- Bottom UI Bar with Inputs and Button -->
    <div id="ui-bar-bottom">
        <div class="input-group">
            <label>L:</label>
            <input type="number" id="input-l" class="dimension-input" min="1" max="6" value="1">
        </div>
        <div class="input-group">
            <label>B:</label>
            <input type="number" id="input-b" class="dimension-input" min="1" max="6" value="1">
        </div>
        <div class="input-group">
            <label>H:</label>
            <input type="number" id="input-h" class="dimension-input" min="1" max="6" value="1">
        </div>
        <button id="toggle-btn">Span: Enabled</button>
    </div>

    <!-- QR Code Element -->
    <img id="qr-display" src="BOX6×6×6qr.png" alt="Scan QR Code">

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let barMesh, internalGrid, exteriorEdges, peanutGroup;
        let handles = [];

        let size = { x: 1, y: 1, z: 1 };
        let canExtend = true; // Toggle state flag

        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        let isDraggingHandle = false;
        let activeHandle = null;

        // UI element references
        const inputL = document.getElementById('input-l');
        const inputB = document.getElementById('input-b');
        const inputH = document.getElementById('input-h');
        const btnToggle = document.getElementById('toggle-btn');

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(6, 6, 8);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            const light = new THREE.DirectionalLight(0xffffff, 1.5);
            light.position.set(10, 20, 15);
            scene.add(light);
            scene.add(new THREE.AmbientLight(0xfff5e6, 0.8));

            const material = new THREE.MeshPhongMaterial({
                color: 0xD2691E,
                transparent: true,
                opacity: 0.15,
                shininess: 60
            });
            barMesh = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), material);
            scene.add(barMesh);

            peanutGroup = new THREE.Group();
            scene.add(peanutGroup);

            internalGrid = new THREE.Group();
            scene.add(internalGrid);

            exteriorEdges = new THREE.Group();
            scene.add(exteriorEdges);

            createHandles();
            updateCuboid();

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.07;
            controls.mouseButtons = { LEFT: THREE.MOUSE.ROTATE, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.ROTATE };
            controls.touches = { ONE: THREE.TOUCH.ROTATE, TWO: THREE.TOUCH.DOLLY_PAN };

            // Button Toggle listener
            btnToggle.addEventListener('click', () => {
                canExtend = !canExtend;
                btnToggle.textContent = canExtend ? "Span: Enabled" : "Span: Disabled";
                btnToggle.classList.toggle('disabled', !canExtend);
            });

            // Input box listeners
            const onInputChange = () => {
                size.x = Math.max(1, Math.min(6, parseInt(inputL.value) || 1));
                size.z = Math.max(1, Math.min(6, parseInt(inputB.value) || 1));
                size.y = Math.max(1, Math.min(6, parseInt(inputH.value) || 1));
                updateCuboid();
            };
            inputL.addEventListener('input', onInputChange);
            inputB.addEventListener('input', onInputChange);
            inputH.addEventListener('input', onInputChange);

            window.addEventListener('pointerdown', onPointerDown);
            window.addEventListener('pointermove', onPointerMove);
            window.addEventListener('pointerup', onPointerUp);
            window.addEventListener('resize', onWindowResize);
        }

        function createHandles() {
            const handleGeo = new THREE.SphereGeometry(0.4);
            const handleMat = new THREE.MeshBasicMaterial({ visible: false });

            const corners = [
                [1, 1, 1], [1, 1, -1], [1, -1, 1], [1, -1, -1],
                [-1, 1, 1], [-1, 1, -1], [-1, -1, 1], [-1, -1, -1]
            ];
            corners.forEach(dir => {
                const handle = new THREE.Mesh(handleGeo, handleMat);
                handle.userData = { dir: new THREE.Vector3(...dir) };
                scene.add(handle);
                handles.push(handle);
            });
        }

        function updateCuboid() {
            // Keep input values in sync with the state
            inputL.value = size.x;
            inputB.value = size.z;
            inputH.value = size.y;

            barMesh.scale.set(size.x, size.y, size.z);

            while (peanutGroup.children.length > 0) peanutGroup.remove(peanutGroup.children[0]);
            while (internalGrid.children.length > 0) internalGrid.remove(internalGrid.children[0]);
            while (exteriorEdges.children.length > 0) exteriorEdges.remove(exteriorEdges.children[0]);

            const hX = size.x / 2, hY = size.y / 2, hZ = size.z / 2;

            const peanutGeo = new THREE.SphereGeometry(0.25, 12, 12);
            const peanutMat = new THREE.MeshPhongMaterial({ color: 0xF5F5DC });

            for (let i = 0; i < size.x; i++) {
                for (let j = 0; j < size.y; j++) {
                    for (let k = 0; k < size.z; k++) {
                        const peanut = new THREE.Mesh(peanutGeo, peanutMat);
                        peanut.position.set((i - hX + 0.5), (j - hY + 0.5), (k - hZ + 0.5));
                        peanutGroup.add(peanut);
                    }
                }
            }

            const intLineMat = new THREE.LineBasicMaterial({ color: 0x555555 });
            const pts = [];
            for (let j = -hY; j <= hY; j++) for (let k = -hZ; k <= hZ; k++) pts.push(new THREE.Vector3(-hX, j, k), new THREE.Vector3(hX, j, k));
            for (let i = -hX; i <= hX; i++) for (let k = -hZ; k <= hZ; k++) pts.push(new THREE.Vector3(i, -hY, k), new THREE.Vector3(i, hY, k));
            for (let i = -hX; i <= hX; i++) for (let j = -hY; j <= hY; j++) pts.push(new THREE.Vector3(i, j, -hZ), new THREE.Vector3(i, j, hZ));

            const gridGeo = new THREE.BufferGeometry().setFromPoints(pts);
            internalGrid.add(new THREE.LineSegments(gridGeo, intLineMat));

            const edgeGeo = new THREE.EdgesGeometry(new THREE.BoxGeometry(size.x, size.y, size.z));
            exteriorEdges.add(new THREE.LineSegments(edgeGeo, new THREE.LineBasicMaterial({ color: 0x000000 })));

            handles.forEach(h => {
                const d = h.userData.dir;
                h.position.set(hX * d.x, hY * d.y, hZ * d.z);
            });
        }

        function onPointerDown(event) {
            // Prevent interaction through the UI components
            if (event.target.closest('#toggle-btn') || event.target.closest('#info-box') ||
                event.target.closest('#ui-bar-bottom') || event.target.id === 'qr-display') return;

            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(pointer, camera);

            const intersects = raycaster.intersectObjects(handles);

            if (intersects.length > 0 && canExtend) {
                isDraggingHandle = true;
                activeHandle = intersects[0].object;
                controls.enabled = false;
            } else {
                isDraggingHandle = false;
                controls.enabled = true;
            }
        }

        function onPointerMove(event) {
            if (!isDraggingHandle || !activeHandle) return;
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(pointer, camera);
            const plane = new THREE.Plane();
            plane.setFromNormalAndCoplanarPoint(camera.getWorldDirection(new THREE.Vector3()), activeHandle.position);
            const intersectPoint = new THREE.Vector3();

            if (raycaster.ray.intersectPlane(plane, intersectPoint)) {
                // CONSTRAINT: Capped at 6x6x6 units
                const nextX = Math.max(1, Math.min(6, Math.round(Math.abs(intersectPoint.x) * 2)));
                const nextY = Math.max(1, Math.min(6, Math.round(Math.abs(intersectPoint.y) * 2)));
                const nextZ = Math.max(1, Math.min(6, Math.round(Math.abs(intersectPoint.z) * 2)));

                if (nextX !== size.x || nextY !== size.y || nextZ !== size.z) {
                    size.x = nextX;
                    size.y = nextY;
                    size.z = nextZ;
                    updateCuboid();
                }
            }
        }

        function onPointerUp() {
            isDraggingHandle = false;
            activeHandle = null;
            controls.enabled = true;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>

</html>
