<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>UAE Culture: Box of Dates - Volume Explorer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #ffffff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
        }

        canvas {
            display: block;
        }

        /* --- Main Page Heading --- */
        #main-header {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            font-size: clamp(18px, 3vw, 24px);
            font-weight: 800;
            color: #3B2314;
            z-index: 10;
            pointer-events: none;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.05);
        }

        /* --- Side Panel Textbox (Top Left) --- */
        #info-box {
            position: absolute;
            top: 30px; 
            left: 20px;
            width: 420px; 
            background: rgba(255, 255, 255, 0.95);
            border-left: 8px solid #D2691E;
            border-radius: 15px;
            box-shadow: 2px 2px 20px rgba(0, 0, 0, 0.1);
            z-index: 20;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: max-height 0.4s ease;
            max-height: 90vh;
        }

        #info-box.minimized {
            max-height: 42px; /* Only header height */
        }

        #info-box-header {
            padding: 10px 20px;
            background: rgba(210, 105, 30, 0.08);
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
        }

        #info-box-header:after {
            content: '▲';
            font-size: 10px;
            color: #D2691E;
            transition: transform 0.3s;
        }

        #info-box.minimized #info-box-header:after {
            transform: rotate(180deg);
        }

        .header-title {
            font-size: 13px;
            font-weight: bold;
            color: #D2691E;
            text-transform: uppercase;
        }

        /* Collapsible Section */
        #collapsible-content {
            padding: 0 20px;
            overflow-y: auto;
            transition: opacity 0.3s;
        }

        #info-box.minimized #collapsible-content {
            opacity: 0;
            pointer-events: none;
        }

        #description {
            font-size: 13.5px;
            line-height: 1.4;
            color: #3e2723;
            margin: 15px 0;
        }

        .think-title {
            font-size: 16px;
            font-weight: bold;
            color: #D2691E;
            text-decoration: underline;
            margin-bottom: 10px;
            display: block;
        }

        .think-group {
            margin-bottom: 12px;
            font-size: 13px;
            color: #3B2314;
            line-height: 1.4;
        }

        .question-text {
            color: #4e342e;
            font-weight: 600;
            margin-top: 3px;
            display: block;
            padding-left: 8px;
            border-left: 2px solid #ecdac6;
        }

        /* Fixed Instruction Footer (Always Visible) */
        #fixed-instruction-footer {
            padding: 12px 20px;
            background: #fff;
            border-top: 1px solid #eee;
        }

        .instruction-line {
            display: block;
            font-size: 12px;
            color: #757575;
            font-style: italic;
            line-height: 1.4;
            margin-bottom: 6px;
            text-align: left;
        }

        .instruction-line:last-child { margin-bottom: 0; }

        /* --- Bottom UI Bar --- */
        #ui-bar-bottom {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 15px;
            background: rgba(255, 255, 255, 0.95);
            padding: 10px 20px;
            border-radius: 50px;
            box-shadow: 0 4px 15px rgba(0, 136, 255, 0.2);
            z-index: 100;
            border: 1px solid #ddd;
        }

        .input-group {
            display: flex;
            align-items: center;
            gap: 5px;
            font-weight: bold;
            color: #3B2314;
            font-size: 14px;
        }

        .dimension-input {
            width: 40px;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 5px;
            text-align: center;
        }

        #toggle-btn {
            padding: 10px 20px;
            font-size: 14px;
            font-weight: bold;
            color: white;
            background-color: #0088ff;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        #toggle-btn.disabled { background-color: #555555; }

        #qr-display {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 120px;
            height: 120px;
            background: white;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            z-index: 100;
        }
    </style>
</head>

<body>

    <div id="main-header">Exploring Volume Through a Box of Eid Gifts</div>

    <div id="info-box">
        <div id="info-box-header" onclick="document.getElementById('info-box').classList.toggle('minimized')">
            <span class="header-title">Instructions & Tasks</span>
        </div>
        
        <div id="collapsible-content">
            <div id="description">
                This is a model of a box of balls with dates and nuts, commonly shared in the UAE during Islamic occasions, in the shape of a cuboid.
            </div>

            <span class="think-title">Think and Answer</span>
            
            <div class="think-group">
                Look at just one flat layer of balls.
                <span class="question-text">What does the number of balls tell you? Is it same as Area (L×B)?</span>
            </div>

            <div class="think-group">
                Look at how the layers are stacked.
                <span class="question-text">What does the number of layers tell you? Is it same as Height?</span>
            </div>

            <div class="think-group">
                Now, think about the whole box.
                <span class="question-text">What does the total number of balls tell you? Is it same as Volume?</span>
            </div>

            <div class="think-group">
                Division 1: Total balls ÷ layers.
                <span class="question-text">What is the result? Is it same as Volume ÷ Height?</span>
            </div>

            <div class="think-group" style="margin-bottom: 20px;">
                Division 2: Total balls ÷ balls in one layer.
                <span class="question-text">What is the result? Is it same as Volume ÷ Base Area?</span>
            </div>
        </div>

        <div id="fixed-instruction-footer">
            <span class="instruction-line">The interactive cuboid on the right can be expanded up to a dimension of 6×6×6.</span>
            <span class="instruction-line">Use hand gestures to rotate and span the cuboid while exploring these concepts.</span>
            <span class="instruction-line">Use the input boxes to enter the length, breadth, and height of the required cuboid.</span>
            <span class="instruction-line">Disable the “Span” button to prevent accidental changes to the dimensions.</span>
        </div>
    </div>

    <div id="ui-bar-bottom">
        <div class="input-group"><label>L:</label><input type="number" id="input-l" class="dimension-input" min="1" max="6" value="1"></div>
        <div class="input-group"><label>B:</label><input type="number" id="input-b" class="dimension-input" min="1" max="6" value="1"></div>
        <div class="input-group"><label>H:</label><input type="number" id="input-h" class="dimension-input" min="1" max="6" value="1"></div>
        <button id="toggle-btn">Span: Enabled</button>
    </div>

    <img id="qr-display" src="qr.png" alt="Scan QR Code" onerror="this.style.display='none'">

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let barMesh, internalGrid, exteriorEdges, peanutGroup;
        let handles = [];
        let size = { x: 1, y: 1, z: 1 };
        let canExtend = true;

        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        let isDraggingHandle = false;
        let activeHandle = null;

        const inputL = document.getElementById('input-l');
        const inputB = document.getElementById('input-b');
        const inputH = document.getElementById('input-h');
        const btnToggle = document.getElementById('toggle-btn');

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(10, 8, 12); // Slightly closer camera for smaller max span

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            const light = new THREE.DirectionalLight(0xffffff, 1.5);
            light.position.set(15, 25, 20);
            scene.add(light);
            scene.add(new THREE.AmbientLight(0xfff5e6, 0.8));

            barMesh = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshPhongMaterial({ color: 0xD2691E, transparent: true, opacity: 0.15, shininess: 60 }));
            scene.add(barMesh);

            peanutGroup = new THREE.Group(); scene.add(peanutGroup);
            internalGrid = new THREE.Group(); scene.add(internalGrid);
            exteriorEdges = new THREE.Group(); scene.add(exteriorEdges);

            createHandles();
            updateCuboid();

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.mouseButtons = { LEFT: THREE.MOUSE.ROTATE, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.ROTATE };
            controls.touches = { ONE: THREE.TOUCH.ROTATE, TWO: THREE.TOUCH.DOLLY_PAN };

            btnToggle.addEventListener('click', () => {
                canExtend = !canExtend;
                btnToggle.textContent = canExtend ? "Span: Enabled" : "Span: Disabled";
                btnToggle.classList.toggle('disabled', !canExtend);
            });

            const onInputChange = () => {
                // FIXED CLAMP AT 6
                size.x = Math.max(1, Math.min(6, parseInt(inputL.value) || 1));
                size.z = Math.max(1, Math.min(6, parseInt(inputB.value) || 1));
                size.y = Math.max(1, Math.min(6, parseInt(inputH.value) || 1));
                updateCuboid();
            };
            inputL.addEventListener('input', onInputChange);
            inputB.addEventListener('input', onInputChange);
            inputH.addEventListener('input', onInputChange);

            window.addEventListener('pointerdown', (e) => {
                if (e.target.closest('#toggle-btn') || e.target.closest('#info-box') || e.target.closest('#ui-bar-bottom')) return;
                pointer.x = (e.clientX / window.innerWidth) * 2 - 1;
                pointer.y = -(e.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(pointer, camera);
                const intersects = raycaster.intersectObjects(handles);
                if (intersects.length > 0 && canExtend) { isDraggingHandle = true; activeHandle = intersects[0].object; controls.enabled = false; }
                else { isDraggingHandle = false; controls.enabled = true; }
            });

            window.addEventListener('pointermove', (e) => {
                if (!isDraggingHandle || !activeHandle) return;
                pointer.x = (e.clientX / window.innerWidth) * 2 - 1;
                pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(pointer, camera);
                const pt = new THREE.Vector3();
                raycaster.ray.intersectPlane(new THREE.Plane().setFromNormalAndCoplanarPoint(camera.getWorldDirection(new THREE.Vector3()), activeHandle.position), pt);
                
                // FIXED CLAMP AT 6 FOR GESTURES
                const nx = Math.max(1, Math.min(6, Math.round(Math.abs(pt.x) * 2)));
                const ny = Math.max(1, Math.min(6, Math.round(Math.abs(pt.y) * 2)));
                const nz = Math.max(1, Math.min(6, Math.round(Math.abs(pt.z) * 2)));
                
                if (nx !== size.x || ny !== size.y || nz !== size.z) { size.x = nx; size.y = ny; size.z = nz; updateCuboid(); }
            });

            window.addEventListener('pointerup', () => { isDraggingHandle = false; activeHandle = null; controls.enabled = true; });
            window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
        }

        function createHandles() {
            const geo = new THREE.SphereGeometry(0.4);
            const mat = new THREE.MeshBasicMaterial({ visible: false });
            const corners = [[1, 1, 1], [1, 1, -1], [1, -1, 1], [1, -1, -1], [-1, 1, 1], [-1, 1, -1], [-1, -1, 1], [-1, -1, -1]];
            corners.forEach(dir => {
                const h = new THREE.Mesh(geo, mat); h.userData = { dir: new THREE.Vector3(...dir) };
                scene.add(h); handles.push(h);
            });
        }

        function updateCuboid() {
            inputL.value = size.x; inputB.value = size.z; inputH.value = size.y;
            barMesh.scale.set(size.x, size.y, size.z);
            while (peanutGroup.children.length > 0) peanutGroup.remove(peanutGroup.children[0]);
            while (internalGrid.children.length > 0) internalGrid.remove(internalGrid.children[0]);
            while (exteriorEdges.children.length > 0) exteriorEdges.remove(exteriorEdges.children[0]);
            const hX = size.x / 2, hY = size.y / 2, hZ = size.z / 2;
            const pGeo = new THREE.SphereGeometry(0.25, 12, 12);
            const pMat = new THREE.MeshPhongMaterial({ color: 0xF5F5DC });
            for (let i = 0; i < size.x; i++) {
                for (let j = 0; j < size.y; j++) {
                    for (let k = 0; k < size.z; k++) {
                        const p = new THREE.Mesh(pGeo, pMat); p.position.set((i - hX + 0.5), (j - hY + 0.5), (k - hZ + 0.5));
                        peanutGroup.add(p);
                    }
                }
            }
            const pts = [];
            for (let j = -hY; j <= hY; j++) for (let k = -hZ; k <= hZ; k++) pts.push(new THREE.Vector3(-hX, j, k), new THREE.Vector3(hX, j, k));
            for (let i = -hX; i <= hX; i++) for (let k = -hZ; k <= hZ; k++) pts.push(new THREE.Vector3(i, -hY, k), new THREE.Vector3(i, hY, k));
            for (let i = -hX; i <= hX; i++) for (let j = -hY; j <= hY; j++) pts.push(new THREE.Vector3(i, j, -hZ), new THREE.Vector3(i, j, hZ));
            internalGrid.add(new THREE.LineSegments(new THREE.BufferGeometry().setFromPoints(pts), new THREE.LineBasicMaterial({ color: 0x555555 })));
            exteriorEdges.add(new THREE.LineSegments(new THREE.EdgesGeometry(new THREE.BoxGeometry(size.x, size.y, size.z)), new THREE.LineBasicMaterial({ color: 0x000000 })));
            handles.forEach(h => h.position.set(hX * h.userData.dir.x, hY * h.userData.dir.y, hZ * h.userData.dir.z));
        }

        function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
    </script>
</body>

</html>
