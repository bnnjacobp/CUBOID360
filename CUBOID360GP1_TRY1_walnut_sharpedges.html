<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Walnut Packet - Think-Pair-Share</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #ffffff;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            touch-action: none;
        }

        canvas {
            display: block;
        }

        /* --- UI CONTAINER: CURVY CORNERS + SHADOW + SIDE PANEL --- */
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 450px;
            background: rgba(255, 255, 255, 0.95);
            pointer-events: auto; /* Changed to auto to allow clicking the header */
            z-index: 10;
            border-radius: 15px;
            border-left: 6px solid #5d4037; /* Side Panel */
            box-shadow: 2px 2px 15px rgba(0, 0, 0, 0.08);
            user-select: none;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #info-box-header {
            padding: 12px 20px;
            background: rgba(160, 82, 45, 0.1);
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #primary-title {
            font-size: 22px;
            font-weight: 900;
            color: #a0522d;
            margin: 0;
            letter-spacing: -0.5px;
        }

        #info-box-header:after {
            content: 'â–²';
            font-size: 10px;
            color: #a0522d;
            transition: transform 0.3s;
        }

        #ui-container.minimized #info-box-header:after {
            transform: rotate(180deg);
        }

        /* Collapsible Section for Questions */
        #collapsible-content {
            padding: 0 25px;
            max-height: 500px;
            overflow-y: auto;
            transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s;
        }

        #ui-container.minimized #collapsible-content {
            max-height: 0;
            opacity: 0;
        }

        .question-item {
            font-size: 14.5px;
            color: #3e2723;
            margin: 15px 0;
            line-height: 1.5;
            font-weight: 600;
        }

        .question-number {
            color: #a0522d;
            margin-right: 5px;
        }

        /* Fixed Instruction Section (Always Visible) */
        #fixed-footer {
            padding: 15px 25px;
            background: white;
            border-top: 1px solid #eee;
        }

        #gesture-instruction {
            font-size: 13px;
            color: #757575;
            font-style: italic;
            margin: 0;
        }

        /* QR Code Styling */
        #qr-code {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 120px;
            height: 120px;
            border: 1px solid #ddd;
            padding: 5px;
            background: #fff;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            z-index: 10;
        }
    </style>
</head>

<body>

    <div id="ui-container">
        <!-- Tapping this header minimizes the questions -->
        <div id="info-box-header" onclick="document.getElementById('ui-container').classList.toggle('minimized')">
            <span id="primary-title">ðŸ¤” Thinkâ€“Pairâ€“Share Questions</span>
        </div>

        <div id="collapsible-content">
            <div class="question-item"><span class="question-number">1.</span> How many cube boxes are there in one layer of the cuboid? How did you find it?</div>
            <div class="question-item"><span class="question-number">2.</span> How many layers are stacked in the cuboid, and what does this represent?</div>
            <div class="question-item"><span class="question-number">3.</span> Without counting one by one, how can you find the total number of cube boxes inside the cuboid?</div>
            <div class="question-item"><span class="question-number">4.</span> What is the volume of the cuboid?</div>
            <div class="question-item"><span class="question-number">5.</span> Write the formula to find the volume of a cuboid.</div>
        </div>

        <!-- Instructions remain visible always -->
        <div id="fixed-footer">
            <p id="gesture-instruction">
                Use hand gestures to rotate and span the cuboid while exploring these concepts
            </p>
        </div>
    </div>

    <img src="walnutsqr.png" id="qr-code" alt="Scan QR Code">

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let mainMesh, internalGrid, exteriorEdges, walnutGroup;
        let handles = [];
        const size = { x: 3, y: 1, z: 2 };

        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        let isDraggingHandle = false;
        let activeHandle = null;

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(8, 6, 10);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            document.body.appendChild(renderer.domElement);

            const sunLight = new THREE.DirectionalLight(0xffffff, 2.5);
            sunLight.position.set(10, 20, 15);
            scene.add(sunLight);
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));

            mainMesh = new THREE.Mesh(
                new THREE.BoxGeometry(1, 1, 1),
                new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.15 })
            );
            scene.add(mainMesh);

            walnutGroup = new THREE.Group();
            scene.add(walnutGroup);
            internalGrid = new THREE.Group();
            scene.add(internalGrid);
            exteriorEdges = new THREE.Group();
            scene.add(exteriorEdges);

            createHandles();
            updateCuboid();

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.mouseButtons = { LEFT: THREE.MOUSE.ROTATE, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.ROTATE };
            controls.touches = { ONE: THREE.TOUCH.ROTATE, TWO: THREE.TOUCH.DOLLY_PAN };

            window.addEventListener('pointerdown', onPointerDown);
            window.addEventListener('pointermove', onPointerMove);
            window.addEventListener('pointerup', onPointerUp);
            window.addEventListener('resize', onWindowResize);
        }

        function createHandles() {
            const handleGeo = new THREE.SphereGeometry(0.5);
            const handleMat = new THREE.MeshBasicMaterial({ visible: false });
            const corners = [[1, 1, 1], [1, 1, -1], [1, -1, 1], [1, -1, -1], [-1, 1, 1], [-1, 1, -1], [-1, -1, 1], [-1, -1, -1]];
            corners.forEach(dir => {
                const handle = new THREE.Mesh(handleGeo, handleMat);
                handle.userData = { dir: new THREE.Vector3(...dir) };
                scene.add(handle);
                handles.push(handle);
            });
        }

        function createDetailedWalnut() {
            const geo = new THREE.SphereGeometry(0.3, 64, 64);
            const pos = geo.attributes.position;
            const v = new THREE.Vector3();
            for (let i = 0; i < pos.count; i++) {
                v.fromBufferAttribute(pos, i);
                const angle = Math.atan2(v.x, v.z);
                const ridges = Math.abs(Math.sin(angle * 4.0)) * 0.05;
                const noise = (Math.sin(v.x * 25) * Math.sin(v.y * 30) * Math.cos(v.z * 25)) * 0.02;
                const wave = (Math.cos(v.y * 12) * Math.sin(v.x * 8)) * 0.02;
                v.addScaledVector(v, ridges + noise + wave);
                v.y *= 1.25; v.x *= 0.95;
                pos.setXYZ(i, v.x, v.y, v.z);
            }
            geo.computeVertexNormals();
            return geo;
        }

        function updateCuboid() {
            mainMesh.scale.set(size.x, size.y, size.z);
            while (walnutGroup.children.length > 0) walnutGroup.remove(walnutGroup.children[0]);
            while (internalGrid.children.length > 0) internalGrid.remove(internalGrid.children[0]);
            while (exteriorEdges.children.length > 0) exteriorEdges.remove(exteriorEdges.children[0]);

            const hX = size.x / 2, hY = size.y / 2, hZ = size.z / 2;
            const walnutGeo = createDetailedWalnut();
            const walnutMat = new THREE.MeshStandardMaterial({ color: 0xac7a4f, roughness: 0.9, metalness: 0.0 });

            for (let i = 0; i < size.x; i++) {
                for (let j = 0; j < size.y; j++) {
                    for (let k = 0; k < size.z; k++) {
                        const nut = new THREE.Mesh(walnutGeo, walnutMat);
                        nut.position.set((i - hX + 0.5), (j - hY + 0.5), (k - hZ + 0.5));
                        nut.rotation.set(Math.random() * 6, Math.random() * 6, Math.random() * 6);
                        walnutGroup.add(nut);
                    }
                }
            }

            const sharpMat = new THREE.LineBasicMaterial({ color: 0x000000 });
            const pts = [];
            for (let j = -hY; j <= hY; j++) for (let k = -hZ; k <= hZ; k++) pts.push(new THREE.Vector3(-hX, j, k), new THREE.Vector3(hX, j, k));
            for (let i = -hX; i <= hX; i++) for (let k = -hZ; k <= hZ; k++) pts.push(new THREE.Vector3(i, -hY, k), new THREE.Vector3(i, hY, k));
            for (let i = -hX; i <= hX; i++) for (let j = -hY; j <= hY; j++) pts.push(new THREE.Vector3(i, j, -hZ), new THREE.Vector3(i, j, hZ));
            internalGrid.add(new THREE.LineSegments(new THREE.BufferGeometry().setFromPoints(pts), sharpMat));
            exteriorEdges.add(new THREE.LineSegments(new THREE.EdgesGeometry(new THREE.BoxGeometry(size.x, size.y, size.z)), sharpMat));

            handles.forEach(h => { h.position.set(hX * h.userData.dir.x, hY * h.userData.dir.y, hZ * h.userData.dir.z); });
        }

        function onPointerDown(e) {
            // Block 3D actions if clicking inside the UI panel
            if (e.target.closest('#ui-container') || e.target.id === 'qr-code') return;

            pointer.x = (e.clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(handles);
            if (intersects.length > 0) { isDraggingHandle = true; activeHandle = intersects[0].object; controls.enabled = false; }
            else { isDraggingHandle = false; controls.enabled = true; }
        }

        function onPointerMove(e) {
            if (!isDraggingHandle || !activeHandle) return;
            pointer.x = (e.clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(pointer, camera);
            const intersectPoint = new THREE.Vector3();
            raycaster.ray.intersectPlane(new THREE.Plane().setFromNormalAndCoplanarPoint(camera.getWorldDirection(new THREE.Vector3()), activeHandle.position), intersectPoint);
            const ny = Math.max(1, Math.min(3, Math.round(Math.abs(intersectPoint.y) * 2)));
            if (ny !== size.y) { size.y = ny; updateCuboid(); }
        }

        function onPointerUp() { isDraggingHandle = false; activeHandle = null; controls.enabled = true; }
        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
    </script>
</body>

</html>
