<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Walnut Packet - Curvy Shadow UI</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #ffffff;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            touch-action: none;
        }

        canvas {
            display: block;
        }

        /* --- UPDATED UI: CURVY CORNERS + SHADOW + SIDE PANEL --- */
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            max-width: 500px;
            /* Semi-transparent white background to host the shadow */
            background: rgba(255, 255, 255, 0.9);
            padding: 20px 25px;
            pointer-events: none;
            z-index: 10;

            /* Curvy Corners */
            border-radius: 15px;

            /* The required Side Panel (Deep Walnut Brown) */
            border-left: 6px solid #5d4037;

            /* Shadow Design exactly as in Breadbox */
            box-shadow: 2px 2px 15px rgba(0, 0, 0, 0.08);
            user-select: none;
        }

        #primary-title {
            font-size: 36px;
            font-weight: 900;
            /* Sienna Brown Color for "Try it!" */
            color: #a0522d;
            margin-bottom: 5px;
            display: block;
            letter-spacing: -1px;
        }

        #main-heading {
            font-size: 15.5px;
            font-weight: 700;
            color: #3e2723;
            /* Dark Cocoa Brown */
            line-height: 1.5;
            margin-bottom: 18px;
        }

        .pointer-item {
            font-size: 14.5px;
            color: #4e342e;
            /* Warm Medium Brown */
            margin-bottom: 10px;
            display: list-item;
            list-style-type: disc;
            margin-left: 25px;
            line-height: 1.4;
        }

        #gesture-instruction {
            font-size: 13px;
            color: #757575;
            /* Grey */
            font-style: italic;
            /* Italics */
            margin-top: 15px;
            border-top: 1px solid #eee;
            padding-top: 10px;
        }

        /* QR Code Styling */
        #qr-code {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 120px;
            height: 120px;
            border: 1px solid #ddd;
            padding: 5px;
            background: #fff;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            z-index: 10;
        }
    </style>
</head>

<body>

    <div id="ui-container">
        <span id="primary-title">Try it!</span>
        <div id="main-heading">
            This is a model of a packet of walnuts in the shape of a cuboid. Count the number of walnuts in each layer
            and multiply it by the number of layers to answer the following questions:
        </div>
        <div class="pointer-item">What does the number of walnuts in each layer represent?</div>
        <div class="pointer-item">What does the number of layers represent?</div>
        <div class="pointer-item">What does the total number of walnuts in all the layers together represent?</div>

        <div id="gesture-instruction">
            Use hand gestures to rotate and span the cuboid while exploring these concepts
        </div>
    </div>

    <img src="walnutsqr.png" id="qr-code" alt="Scan QR Code">

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let mainMesh, internalGrid, exteriorEdges, walnutGroup;
        let handles = [];
        const size = { x: 3, y: 1, z: 2 };

        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        let isDraggingHandle = false;
        let activeHandle = null;

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(8, 6, 10);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            document.body.appendChild(renderer.domElement);

            const sunLight = new THREE.DirectionalLight(0xffffff, 2.5);
            sunLight.position.set(10, 20, 15);
            scene.add(sunLight);
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));

            mainMesh = new THREE.Mesh(
                new THREE.BoxGeometry(1, 1, 1),
                new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.15 })
            );
            scene.add(mainMesh);

            walnutGroup = new THREE.Group();
            scene.add(walnutGroup);
            internalGrid = new THREE.Group();
            scene.add(internalGrid);
            exteriorEdges = new THREE.Group();
            scene.add(exteriorEdges);

            createHandles();
            updateCuboid();

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.mouseButtons = { LEFT: THREE.MOUSE.ROTATE, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.ROTATE };
            controls.touches = { ONE: THREE.TOUCH.ROTATE, TWO: THREE.TOUCH.DOLLY_PAN };

            window.addEventListener('pointerdown', onPointerDown);
            window.addEventListener('pointermove', onPointerMove);
            window.addEventListener('pointerup', onPointerUp);
            window.addEventListener('resize', onWindowResize);
        }

        function createHandles() {
            const handleGeo = new THREE.SphereGeometry(0.5);
            const handleMat = new THREE.MeshBasicMaterial({ visible: false });
            const corners = [[1, 1, 1], [1, 1, -1], [1, -1, 1], [1, -1, -1], [-1, 1, 1], [-1, 1, -1], [-1, -1, 1], [-1, -1, -1]];
            corners.forEach(dir => {
                const handle = new THREE.Mesh(handleGeo, handleMat);
                handle.userData = { dir: new THREE.Vector3(...dir) };
                scene.add(handle);
                handles.push(handle);
            });
        }

        function createDetailedWalnut() {
            const geo = new THREE.SphereGeometry(0.3, 64, 64);
            const pos = geo.attributes.position;
            const v = new THREE.Vector3();
            for (let i = 0; i < pos.count; i++) {
                v.fromBufferAttribute(pos, i);
                const angle = Math.atan2(v.x, v.z);
                const ridges = Math.abs(Math.sin(angle * 4.0)) * 0.05;
                const noise = (Math.sin(v.x * 25) * Math.sin(v.y * 30) * Math.cos(v.z * 25)) * 0.02;
                const wave = (Math.cos(v.y * 12) * Math.sin(v.x * 8)) * 0.02;
                v.addScaledVector(v, ridges + noise + wave);
                v.y *= 1.25; v.x *= 0.95;
                pos.setXYZ(i, v.x, v.y, v.z);
            }
            geo.computeVertexNormals();
            return geo;
        }

        function updateCuboid() {
            mainMesh.scale.set(size.x, size.y, size.z);
            while (walnutGroup.children.length > 0) walnutGroup.remove(walnutGroup.children[0]);
            while (internalGrid.children.length > 0) internalGrid.remove(internalGrid.children[0]);
            while (exteriorEdges.children.length > 0) exteriorEdges.remove(exteriorEdges.children[0]);

            const hX = size.x / 2, hY = size.y / 2, hZ = size.z / 2;
            const walnutGeo = createDetailedWalnut();
            const walnutMat = new THREE.MeshStandardMaterial({ color: 0xac7a4f, roughness: 0.9, metalness: 0.0 });

            for (let i = 0; i < size.x; i++) {
                for (let j = 0; j < size.y; j++) {
                    for (let k = 0; k < size.z; k++) {
                        const nut = new THREE.Mesh(walnutGeo, walnutMat);
                        nut.position.set((i - hX + 0.5), (j - hY + 0.5), (k - hZ + 0.5));
                        nut.rotation.set(Math.random() * 6, Math.random() * 6, Math.random() * 6);
                        walnutGroup.add(nut);
                    }
                }
            }

            const sharpMat = new THREE.LineBasicMaterial({ color: 0x000000 });
            const pts = [];
            for (let j = -hY; j <= hY; j++) for (let k = -hZ; k <= hZ; k++) pts.push(new THREE.Vector3(-hX, j, k), new THREE.Vector3(hX, j, k));
            for (let i = -hX; i <= hX; i++) for (let k = -hZ; k <= hZ; k++) pts.push(new THREE.Vector3(i, -hY, k), new THREE.Vector3(i, hY, k));
            for (let i = -hX; i <= hX; i++) for (let j = -hY; j <= hY; j++) pts.push(new THREE.Vector3(i, j, -hZ), new THREE.Vector3(i, j, hZ));
            internalGrid.add(new THREE.LineSegments(new THREE.BufferGeometry().setFromPoints(pts), sharpMat));
            exteriorEdges.add(new THREE.LineSegments(new THREE.EdgesGeometry(new THREE.BoxGeometry(size.x, size.y, size.z)), sharpMat));

            handles.forEach(h => { h.position.set(hX * h.userData.dir.x, hY * h.userData.dir.y, hZ * h.userData.dir.z); });
        }

        function onPointerDown(e) {
            pointer.x = (e.clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(handles);
            if (intersects.length > 0) { isDraggingHandle = true; activeHandle = intersects[0].object; controls.enabled = false; }
            else { isDraggingHandle = false; controls.enabled = true; }
        }

        function onPointerMove(e) {
            if (!isDraggingHandle || !activeHandle) return;
            pointer.x = (e.clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(pointer, camera);
            const intersectPoint = new THREE.Vector3();
            raycaster.ray.intersectPlane(new THREE.Plane().setFromNormalAndCoplanarPoint(camera.getWorldDirection(new THREE.Vector3()), activeHandle.position), intersectPoint);
            const ny = Math.max(1, Math.min(3, Math.round(Math.abs(intersectPoint.y) * 2)));
            if (ny !== size.y) { size.y = ny; updateCuboid(); }
        }

        function onPointerUp() { isDraggingHandle = false; activeHandle = null; controls.enabled = true; }
        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
    </script>
</body>

</html>
